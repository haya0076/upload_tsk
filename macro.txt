Option Explicit

Const cBlue As String = -4165632
Const cWBlue As String = -1003520
Const cRed As String = -16776961

Type tStack

    outPutRow As Long
    crrFncName As String
    sqlCnt As Long 'Execute

End Type


Type tIndexedtext

    index As String
    line As String
    fileName As String

End Type


Sub ■()
End Sub


Sub keybind()
'+ ^ %

Application.OnKey "+^%h", "showHiddenRow"
Application.OnKey "+^h", "HideRoW_ast"

'Application.OnKey "+^%h", "showHiddenRow"
'Application.OnKey "+^h", "HideRoW"

'HideCol
'showHiddenCol

End Sub


Sub PickLabel_Full(inptFileCol As Long, inptLabelCol As Long)
Dim i As Long
Dim ii As Long
Dim wsDst As Worksheet: Set wsDst = SelectOrCreateWs("INDEX")
Dim wsFrm As Worksheet: Set wsFrm = ThisWorkbook.Worksheets("DOWNLOAD")
Dim ldstRow As Long: ldstRow = 2
Dim sSp As String
Dim sPtn As String
Dim lFRM_FILE As Long: lFRM_FILE = inptFileCol
Dim lFRM_LABEL As Long: lFRM_LABEL = inptLabelCol

With wsDst
    If .Range("A1").Value = "OFF" Then Exit Sub
    .Range(.Cells(2, 1), .Cells(.Rows.Count, .Columns.Count)).Clear
End With

With wsFrm

    For i = 2 To .Cells(Rows.Count, lFRM_FILE).End(xlUp).Row
    
     If .Cells(i, lFRM_LABEL).Value <> "" And _
         Left(Trim(.Cells(i, lFRM_LABEL)), 1) = "【" Or _
         .Cells(i, lFRM_LABEL).Value = "*" _
        Then

        Select Case True

            Case Left(Trim(.Cells(i, lFRM_LABEL)), 4) = "【FNC"
                 sSp = ""

            Case Left(Trim(.Cells(i, lFRM_LABEL)), 4) = "【SQL"
                sSp = "   "

            Case Left(Trim(.Cells(i, lFRM_LABEL)), 1) = "【"
                sSp = "      "

            Case Left(Trim(.Cells(i, lFRM_LABEL)), 1) = "*"
                sSp = "    　    "
         End Select
         
         
        For ii = 1 To 9
        
            If ii = lFRM_LABEL Then
                wsDst.Cells(ldstRow, ii).Value = sSp & wsFrm.Cells(i, ii)
            Else
                wsDst.Cells(ldstRow, ii).Value = wsFrm.Cells(i, ii)
            End If
            
        Next ii
         
        ldstRow = ldstRow + 1
        
        End If

    Next i
    
End With

 
End Sub


Sub PickLabel()
Dim lFRM_FILE As Long: lFRM_FILE = fCol("A")
Dim lFRM_LABEL As Long: lFRM_LABEL = fCol("D")

Dim lDST_LABEL As Long: lDST_LABEL = fCol("D")
Dim rCell As Range
Dim sPtn As String
sPtn = "【SQL"

'Application.ScreenUpdating = False

Call PickLabel_Full(lFRM_FILE, lFRM_LABEL)

    With ThisWorkbook.Sheets("index")

        .Range(.Cells(2, lDST_LABEL), .Cells(.Cells(Rows.Count, lDST_LABEL).End(xlUp).Row, lDST_LABEL)).Select

        For Each rCell In Selection
            
            If rCell.Value <> "" Then
                If fRegxTest(Trim(rCell.Value), sPtn) = True Then
                    rCell.EntireRow.Hidden = False
                Else
                    rCell.EntireRow.Hidden = True
                    
                End If
            End If
            
        Next rCell



    End With

Application.ScreenUpdating = True

End Sub


Sub ooo_SETUP_BOOK_oooo()
End Sub


Sub SetUpPrgWorkBook()

'Delete Sht Not(SEUP Or LINKSHT Or USER_PRM)
'Create Sht (PRG_PRM)

Dim ws As Worksheet
Dim sWs As String
Dim sPtn As String
Dim o As Object

Application.DisplayAlerts = False


For Each ws In ThisWorkbook.Sheets

    If Not fRegxTest(ws.Name, "SETUP|LinkSht|PRG_PRM") Then
        ws.Delete
    End If

Next ws


sWs = "USER_PRM"

With SelectOrCreateWs(sWs)
    'CONST
    
    .Cells.Clear
    .Range("A1").Value = "FILE"
    .Range("B1").Value = "VARIANT"
    .Range("C1").Value = "VALUE"
    .Range("D1").Value = "SHEET"
    .Range("E1").Value = "COMMENT"
    
    'Const\s+([_\d\w]+)[\s\d\w]+=\s+([_""\d\w]+)
    Call PrgDownloadMatches(fKey2Val("PRG_SHT_PRG", "PRG_PTN_CNST"), sWs, "A:0,0|B:0,1")
    
End With


sWs = "DOWNLOAD"

With SelectOrCreateWs(sWs)
    'CONST
    
    .Cells.Clear
    .Range("A1").Value = "FILE"
    .Range("B1").Value = "VARIANT"
    .Range("C1").Value = "VALUE"
    .Range("D1").Value = "SHEET"
    .Range("E1").Value = "COMMENT"
    
    'Const\s+([_\d\w]+)[\s\d\w]+=\s+([_""\d\w]+)
    Call PrgDownloadMatches("|", sWs, "A:0,0")

End With


With SelectOrCreateWs("PRG_SVR")
    'SERVER
    
    
End With

With SelectOrCreateWs("PRG_VER")
    'VERSION
    
    
End With


Application.DisplayAlerts = True

End Sub




Function fPrgRet1(inptStr As String, inptCase As String) As String
'inptStr = column | match | submatch

Dim sResult As String

Select Case inptCase
    Case "column"
        sResult = fSplit(inptStr, 1, ":")
        
    Case "match"
        sResult = fSplit( _
                        fSplit(inptStr, 2, ":") _
                        , 1 _
                        , ",")
    Case "submatch"
        sResult = fSplit( _
                        fSplit(inptStr, 2, ":") _
                        , 2 _
                        , ",")
    Case Else
        Stop
End Select
    
fPrgRet1 = sResult
    
End Function

Sub PrgDownloadMatches(inptPtn As String, inptShtName As String, inptCells As String)
'full code patern => "|"
Dim vFile As Variant
Dim sFolder As String: sFolder = fKey2Val("PRG_SHT_SETUP", "PRJ_SRC_PATH")
Dim sLine As String
Dim lRow As Long: lRow = 2
Dim lCnt As Long: lCnt = 1    'total line count
Dim lIndex As Long            'temp index

Dim sPtn As String: sPtn = inptPtn
Dim sShtN As String: sShtN = inptShtName
Dim sCells As String: sCells = inptCells
Dim sResult As String

                                    
'Dim sthOut As Worksheet: Set shtout = SelectOrCreateWs("FNC_LIST")

'If sMatchKey = "NotMatch" Or sMatchKey = "" Then printLog ("DownloadMatchList Key2Ver Error")

'MAKE FUNCTION NAME LIST
For Each vFile In fGetFilePathInFolder(sFolder) 'Folder path("C:\ANY") : string  =>  File list : object

    With CreateObject("Scripting.FileSystemObject").OpenTextFile(CStr(vFile))
            
     Do While .AtEndOfStream <> True
                
                sLine = CStr(.readline)
            
                 'Join split lines
                 If Right(sLine, 2) = " _" Then
                  'splited
                  
                      lIndex = lCnt
                      slinetmp = sLine
                     
                     Do
                         sLine = CStr(.readline)
                         slinetmp = slinetmp & sLine
                          lCnt = lCnt + 1
                     Loop While Right(sLine, 2) = " _"
                     
                     sLine = slinetmp
                     sLine = fReplaceRegx(sLine, "\(?\s_[\s\r]+\)?", " ", True) & vbLf  'replace "_ \n" to " "
                     slinetmp = ""
                       
                Else
                'not
                     lIndex = lCnt
                     sLine = sLine
                   
                 End If
    
    
                ' >> regx match
                
                'out put line
                With ThisWorkbook.Sheets(sShtN)
                
                        If fRegxTest(sLine, sPtn) = True Then
                        
                            For Each v In Split(sCells, "|")
                                
                                        .Cells(lRow, 1).Value = _
                                            Dir(vFile) & "(" & lCnt & ")"


                                        .Cells(lRow, fPrgRet1(CStr(v), "column")).Value = _
                                            fRegxMatch(sLine _
                                                        , sPtn _
                                                        , fPrgRet1(CStr(v), "match") _
                                                        , fPrgRet1(CStr(v), "submatch"))
                                
                            Next v
                         
                        'Output line , RegxPatterns1,2
                         
'                         Dim tmpCol As Integer: tmpCol = 1
'                         .Cells(lRow, tmpCol + 0).Value = lIndex
'                         .Cells(lRow, tmpCol + 1).Value = sLine
'                         .Cells(lRow, tmpCol + 2).Value = Dir(CStr(vFile))
'                         .Cells(lRow, tmpCol + 3).Value = fKey2Val("GET_FILETYPE", Dir(CStr(vFile)))
'                         .Cells(lRow, tmpCol + 4).Value = Dir(CStr(vFile)) & "-" & lCnt  'Uniq Key
                    
                    
                    
                        'next row
                        lRow = lRow + 1
                           
                        
                        End If
                        
   
'
'                End If
'
                'next line
                lCnt = lCnt + 1
                    
                    
'               'REGX IN sLine
'
'                Debug.Print sLine
'                If fRegxTest(sLine, sMatchPtn) Then Debug.Print "true"

            End With 'Sheet

            Loop 'PER sLine
                
     .Close
    End With 'ReadObj

    
    'stack=======================

    lCnt = 1

Next vFile

'!YET if duplicate function name
fGetFncCall = sResult
End Sub








Sub ooo_CREATE_PATERN_ooo()
End Sub


Function fPrgCreateRegxPtn(inptPtn As String, inptMatchN As Long, inptSubMatchN As Long) As String
'RET xxx|xxx|xxx AS String IN PRJ FOLDER
'EX:
' CONST
' FNC/SUB
' ATTR Attribute VB_Name = "Sheet10"

Dim vFile As Variant
Dim sFolder As String: sFolder = fKey2Val("PRG_SHT_SETUP", "PRJ_SRC_PATH")
Dim sPtn As String: sPtn = inptPtn
Dim lMatchNum As Long: lMatchNum = inptMatchN
Dim lSubMatchnum As Long: lSubMatchnum = inptSubMatchN
Dim sMatchKey As String: sMatchKey = inptPtn
Dim sLine As String

Dim sResult As String
'Dim sthOut As Worksheet: Set shtout = SelectOrCreateWs("FncList")

'If sMatchKey = "NotMatch" Or sMatchKey = "" Then printLog ("DownloadMatchList Key2Ver Error")

'MAKE FUNCTION NAME LIST
For Each vFile In fGetFilePathInFolder(sFolder) 'Folder path("C:\ANY") : string  =>  File list : object

    With CreateObject("Scripting.FileSystemObject").OpenTextFile(CStr(vFile))
            
            Do While .AtEndOfStream <> True
            
                sLine = CStr(.readline)

                If fRegxTest(sLine, sPtn) Then
                    sLine = fRegxMatch(sLine, sPtn, lMatchNum, lSubMatchnum)
                    
                    sLine = fReplace(sLine, "_", "\_")
                    sLine = fReplace(sLine, "(", "\(")
                    sLine = fReplace(sLine, ")", "\)")
                    sLine = fReplace(sLine, ".", "\.")
                    
                    sResult = WorksheetFunction.TextJoin("|", True, sResult, sLine)
                
                End If
            Loop 'read sLine
    .Close
    End With 'open file
Next vFile

'!YET if duplicate function name
fPrgCreateRegxPtn = sResult

End Function




Sub ooo_WROKSHT_FNC_oooo()
End Sub


Sub WriteValueOnSht(inptSht As String, inptKey As String, inptVal As String)

Dim rCell As Range

If IsExistWs(inptSht) = False Then printLog ("not exist worksheet name :" & inptSht): Exit Sub

With ThisWorkbook.Sheets(inptSht)

    With .Cells(Rows.Count, 1).End(xlUp)

        .Offset(1, 0).Value = inptKey
        .Offset(1, 1).Value = inptVal

    End With

End With

End Sub


Sub ooo_WS_CHIP_oooo()
End Sub




Sub HighlightWord(Optional inptColor As String = "red", Optional inptPtn As String = "PRG_MARK_PTN")
Dim rCell As Range
Dim sText As String
Dim sMatch As String
Dim sPtn As String: sPtn = fKey2Val("LS_BC", inptPtn)
Dim lSt As Long
Dim lEd As Long
Dim lPos As Long: lPos = 0
Dim cColor
Select Case inptColor
 Case "red"
  cColor = cRed
  
 Case "blue"
  cColor = cBlue
 
 Case Else
  clorol = False


End Select

    For Each rCell In Selection

        If rCell <> "" Or _
           fRegxTest(rCell.Value, sPtn) = True _
           Then
            
            sText = rCell.Value
        
            Do While fRegxTest(sText, sPtn) = True

                sMatch = fRegxMatchs(sText, sPtn)(0)
                
                lSt = InStr(sText, sMatch)
                lEd = Len(sMatch)
                
                With rCell.Characters(Start:=lPos + lSt, Length:=lEd).Font
                    
                    If cColor = False Then
                        .ColorIndex = xlAutomatic
                    Else
                        .Color = cColor
                    End If
                    
                End With

                lPos = lPos + lSt + lEd - 1

                sText = Mid(sText, lSt + lEd, Len(sText))
        
            Loop
        
        End If
        
    lPos = 0
    
    Next rCell
    
End Sub


Function fWs_Get_FName(inptStr As String) As String

fWs_Get_FName = fRegxMatchs(inptStr, "\s([\d\w_]+\.(dat|bas|frm|cls))")(0).submatches(0)

End Function


Sub SetUpWorkBook()

Dim ws As Worksheet
'Application.ScreenUpdating = False
    With ThisWorkbook
        For Each ws In .Worksheets
            ActiveWindow.View = xlPageBreakPreview
            ActiveWindow.View = xlNormalView
            ActiveWindow.Zoom = 100
            ActiveWindow.Zoom = 100
            ws.Activate
            ws.Range("A1").Activate
Next ws
    
    .Sheets(1).Activate
    
    End With
'Application.ScreenUpdating = True

End Sub



Function fGetRngPrm(inptSht As String, inptRng As String, inptDsc As String, Optional inptCmt As String = "") As String
' fGetParam("SHT","A","DESC","RG_XXX")

Dim sResult As String

sResult = "[" & inptSht & "]シート"

sResult = sResult & "."

sResult = sResult & "[" & inptRng

sResult = sResult & ":"

sResult = sResult & inptDsc & "]"

If inptCmt <> "" Then
    
    sResult = sResult & " / "
    
    sResult = sResult & inptCmt

End If

fGetCellPrm = sResult

End Function



Sub clearImmediate()

Debug.Print String(1000, vbLf)

End Sub


Sub HideRoW_ast()
    HideRoW ("*")
End Sub

Sub HideRoW(Optional inptMark As String = "")

Dim rCell As Range
Dim sMark As String: sMark = inptMark


For Each rCell In Selection

    If rCell.Value <> "" Then
        
        If sMark = "" Then
            
            rCell.EntireRow.Hidden = True
        
        Else
        
            If rCell.Value = sMark Then rCell.EntireRow.Hidden = True
            
        End If
    
    End If
    
Next rCell


End Sub


Sub HideRow_Regx(inptPtn As String)

Dim rCell As Range
Dim sPtn As String: sPtn = inptPtn


For Each rCell In Selection

    If rCell.Value <> "" Then
        
        If fRegxTest(rCell.Value, sPtn) = False Then
            
            rCell.EntireRow.Hidden = True
        
        End If
    
    End If
    
Next rCell


End Sub

Sub showHiddenRow()

Dim rCell As Range

    For Each rCell In Selection
        
        rCell.EntireRow.Hidden = False
        
    Next rCell

End Sub




Sub HideCol(Optional inptMark As String = "")

Dim rCell As Range
Dim sMark As String: sMark = inptMark


For Each rCell In Selection

    If rCell.Value <> "" Then
        
        If sMark = "" Then
            
            rCell.EntireColumn.Hidden = True
        
        Else
        
            If rCell.Value = sMark Then rCell.EntireColumn.Hidden = True
            
        End If
    
    End If
    
Next rCell


End Sub


Sub showHiddenCol()

Dim rCell As Range

    For Each rCell In Selection
        
        rCell.EntireColumn.Hidden = False
        
    Next rCell

End Sub

Sub ooo_FILE_IO_oooo()
End Sub



Function fReadAllText(inptFilePath As String) As String

With CreateObject("Scripting.FileSystemObject").GetFile(inptFilePath).OpenAsTextStream
    fReadAllText = .readall
End With

End Function



'==================================================================================================

'Files in single Folder

'==================================================================================================

Function fGetFilePathInFolder(inptFolderPath As String) As Object ' Folder path("C:\ANY") : string  =>  File list : object
' return value usage // oArr(n) -> string, oArr.count
' not include folder, file type only

Dim oFSO As Object
Dim oFolder As Object
Dim oFile As Object: Set oFSO = CreateObject("Scripting.FileSystemObject")
Dim sFolder As String: sFolder = inptFolderPath: Set oFolder = oFSO.getFolder(sFolder)
Dim oArr As Object: Set oArr = CreateObject("System.Collections.ArrayList")
Dim i As Integer

For Each oFile In oFolder.Files

    oArr.Add oFile.Path
   ' oFile.Name -> d20211101_mod_DbgXml.bas
   ' oFile.Path -> C:\Users\admin\Documents\tsk\d20211101_mod_DbgXml.bas
    
    i = i + 1

Next oFile

Set fGetFilePathInFolder = oArr

Set oFSO = Nothing
Set oFolder = Nothing
Set oFile = Nothing
Set oArr = Nothing

End Function




'==================================================================================================

'file IO
'file path to text

'==================================================================================================


'
'Function fFilePath2IndexedText(inptFilePath As String, inptDelimiter As String) As Variant
'
'            'file path : string => Lines : variant(tIndexedText)
'
'Dim sFilePath As String: sFilePath = inptFilePath
'Dim sDelimiter As String: sDelimiter = inptDelimiter
'Dim vLines() As tIndexedtext
'            Dim sText As String
'Dim sIndex As String: sIndex = 1
'
'Open sFilePath For Input As #1
'
'    Do Until EOF(1)
'        Line Input #1, sLine
'
'        ReDim vLines(sIndex)
'
'        With vLines(sIndex - 1)
'            .index = slindex
'            .line = sLine
'            .fileName = Dir(sFilePath)
'         End With
''                            sText = sText & Format(sIndex, "0000") & " _:_ "
''                            sText = sText & sLine & vbLf
'    Loop
'
'Close #1
'
'Stop
'
''fFilePath2IndexedText = vLines
'
'End Function

                    



'wait to adding ============================================================


Function fSwith(inptExp As String)
'memo
'Evaluate("left(""ABC"",1)")
'Switch("exp","rslt1","rtn1")
'?  Switch( 0 = 0 , "0", 1=1, "1") -> 0

End Function



Function fCol(inptCol As String) As Long

fCol = Columns(inptCol).Column

End Function



'Sub FillWsFunction_OBJLIST()
'
'Dim i As Long: i = 2
'Dim shtOBJLST: shtOBJLST = "OBJ_LIST"
'
'    Do Until Sheets(shtOBJLST).Cells(i, fCol("A")).Value = ""
'
'     With Sheets(shtOBJLST)
'
'            .Cells(i, fCol("C")).Value = fRegxFirstMatch(.Cells(i, fCol("A")).Value, "[\d\w]+\.(bas|form|cls)")
'
'             i = i + 1
'
'        End With
'
'    Loop
'
'End Sub



Function retThisWbName() As String
    retThisWbName = ThisWorkbook.Name
End Function



Function fRegxTest(ByVal inptStr As String, ByVal inptPattern As String, Optional inptRestrict As String = False) As Boolean

Dim sResult As Boolean

    With CreateObject("VBScript.RegExp")
        
        .Global = True
        .MultiLine = True
        .ignorecase = True
        .Pattern = inptPattern
    
        If .test(inptStr) Then
            
            If inptRestrict <> False Then
            
                sResult = Len(fRegxMatchs(inptStr, inptPattern)(0)) = Len(inptStr)
            
            Else
                
                sResult = True
        
            End If
        
        Else
        
                sResult = False
        
        End If
    
    End With
    
fRegxTest = sResult
    
End Function



Function fRegxFirstMatch(ByVal inptStr As String, _
                                       ByVal inptPattern As String, _
                                       Optional inptSub As String = "") As String
'? fRegxFirstMatch("2023/01/07  01:35            51,209 d20211101_mod_DbgXml.bas", "[\d\w]+\.(bas|form)")
'd20211101_mod_DbgXml.bas

If fRegxMatchs(inptStr, inptPattern) Is Nothing Then
    fRegxFirstMatch = "#VALUE!"
Else
    'mutch or submatch
    If inptSub = "" Then
        fRegxFirstMatch = fRegxMatchs(inptStr, _
                                                        inptPattern)(0)
    Else
        fRegxFirstMatch = fRegxMatchs(inptStr, _
                                                        inptPattern)(0).submatches(CLng(inptSub))
    End If
End If

End Function



Sub printLog(inptStr As String, Optional inptFile As String = "")
Dim sPath As String
Dim sStr As String
sPath = ThisWorkbook.Path & "\" & Switch(inptFile = "", "vbaLog.txt", inptFile <> "", inptFile)

sStr = CStr(Now()) & " : " & inptStr

With CreateObject("Scripting.FileSystemObject")

    If Dir(sPath) <> "" Then
    
'        With .OpenTextFile(sPath, ForAppending)
'            .Write sStr & vbLf
'        End With

        Open sPath For Append As #1
        Print #1, sStr
        Close #1
    
    Else
    
        With .CreaTetextFile(sPath)
            .Write sStr & vbLf
        End With
        
    End If

End With

End Sub



Function IsExistWs(inptShtName As String, Optional inptWb As String = "") As Boolean
Dim sSht As String: sSht = inptShtName
Dim sWb As Workbook: If inptWb = "" Then Set sWb = ThisWorkbook Else Set sWb = Workbooks(inptWb)
Dim s As Worksheet
Dim sResult As Boolean

sResult = False

For Each s In sWb.Sheets
    If s.Name = sSht Then
        sResult = True
    End If
Next s
    

IsExistWs = sResult

End Function


Function SelectOrCreateWs(inptShtName As String, Optional inptWb As String = "") As Worksheet
Dim sSht As String: sSht = inptShtName
Dim sWb As Workbook: If inptWb = "" Then Set sWb = ThisWorkbook Else Set sWb = Workbooks(inptWb)
Dim s As Worksheet
Dim sht As Worksheet

'YET
'If shtOBJDTL Is Nothing Then printLog ("[FAIL] does not find worksheet, be sure that window frame is only single"): Exit Sub

If sSht = "" Then printLog ("Sheet Name Is Empty"): Exit Function
'If Not sWb = ThisWorkbook.Name Then printLog ("External Workbook : SelectOrAddWs")

For Each s In sWb.Sheets
    If s.Name = sSht Then
        printLog ("Select Sheet " & sSht)
        Set SelectOrCreateWs = sWb.Sheets(sSht)
        Exit Function
    End If
Next s

With sWb.Worksheets.Add
    printLog ("Create New Sheet " & sSht)
    .Name = sSht
        Set sht = sWb.Sheets(sSht)
End With

Set SelectOrCreateWs = sht

End Function



Sub ooo_REGX_MATCH_ooo()

End Sub

'==================================================================================================

'regural expression

'==================================================================================================


Function fRegxMatch(ByVal inptStr As String, _
                                  ByVal inptPattern As String, _
                                  Optional inptIndex As Long = 0, _
                                  Optional inptSubIndex As Long = 999999999, _
                                  Optional inptErrMsg As String = "#VALUE!") As String
'[usage] named parameter
'Print fRegxMatch("ABCDE1234", "XYZ", inptErrMsg:="Oooops!")
'Oooops!

Dim sResult As String


If fRegxMatchs(inptStr, inptPattern) Is Nothing Or _
    fRegxMatchs(inptStr, inptPattern).Count <= inptIndex Then

        sResult = inptErrMsg
Else
    
    sResult = fRegxMatchs(inptStr, inptPattern)(inptIndex)

    If inptSubIndex <> 999999999 And _
        fRegxMatchs(inptStr, inptPattern)(inptIndex).submatches.Count - 1 >= inptSubIndex Then
    
        sResult = fRegxMatchs(inptStr, inptPattern)(inptIndex).submatches(CLng(inptSubIndex))
    End If
    
End If

fRegxMatch = sResult

End Function



Function fRegxMatchs(ByVal inptStr As String, _
                                  ByVal inptPattern As String, _
                                  Optional ByVal inptG As String = True, _
                                  Optional ByVal inptM As String = True, _
                                  Optional ByVal inptI As String = True) As Object
'oMatch(0...).Value
'Optinal Global -> If True, then all the matches of the pattern in the string are found.
'                           If False then only the first match is found.

Dim regx As Object: Set regx = CreateObject("vbscript.regexp")
Dim oMatchs As Object

    With regx
        
        .Global = inptG
        .MultiLine = inptM
        .ignorecase = inptI
        .Pattern = inptPattern
    
    End With

If regx.test(inptStr) Then

    Set oMatchs = regx.Execute(inptStr)

End If

Set fRegxMatchs = oMatchs

Set oMatchs = Nothing

End Function



'return match ...
Function fReplace(ByVal inptStr As String, ByVal inptSearch As String, ByVal inptReplace As String) As String
    fReplace = Replace(inptStr, inptSearch, inptReplace)
End Function


Function fReplaceRegx(ByVal inptStr As String, ByVal inptPattern As String, ByVal inptReplace As String, Optional inptGlobal As Boolean = False) As String
'(group) => $n~

Dim regx As Object: Set regx = CreateObject("vbscript.regexp")
    With regx
        .Global = inptGlobal 'isMultiple
        .MultiLine = True
        .ignorecase = True
        .Pattern = inptPattern
    End With

If regx.test(inptStr) Then
    fReplaceRegx = regx.Replace(inptStr, inptReplace)
End If

End Function




'==================================================================================================

'get value

'==================================================================================================



'値の取得""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Function fKey2Val(inptLabel As String, _
                            inptKey As String, _
                            Optional inptErrMsg As String = "#VALUE!", _
                            Optional inptSht As String = "LinkSht") As String
                            
'[usage] named parameter
'Print fRegxMatch("ABCDE1234", "XYZ", inptErrMsg:="Oooops!")
'Oooops!

Dim sLabel As String: sLabel = inptLabel
Dim sKey As String: sKey = inptKey
Dim sData As Variant
Dim sResult As Variant
Dim sShtName As String: sShtName = inptSht
Dim rRng As Range: Set rRng = ThisWorkbook.Sheets(sShtName).Rows(1)
Dim lIndex As Long
Dim bMatch As Boolean
Dim sErrMsg As String: sErrMsg = inptErrMsg

'検索シートの指定列から検索キーと一致した行の配列データを取得
sData = fGetRowData(ThisWorkbook.Name, rRng.Worksheet.Name, sLabel, "A")

'検索キーとの一致なし
If UBound(sData) = -1 Then
    Call printLog("fGetRowData fail : " & inptLabel & " " & inptKey & " " & inptSht)
    fKey2Val = sErrMsg: Exit Function
End If

'行から必要なパラメーターを取り出し
Dim sWb As String: sWb = sData(2)
Dim sWs As String: sWs = sData(3)
Dim sKeyCol As String: sKeyCol = WorksheetFunction.Trim(sData(4))
Dim sRtnCol As String: sRtnCol = WorksheetFunction.Trim(sData(5))

'エラー出力
If sWb = "" Or sWb = sErrMsg Then Call printLog("sWb : " & sWb)
If sWs = "" Or sWs = sErrMsg Then Call printLog("sWs : " & sWs)
If sKeyCol = "" Or sKeyCol = sErrMsg Then Call printLog("sKeyCol : " & sKeyCol)
If sRtnCol = "" Or sRtnCol = sErrMsg Then Call printLog("sRtnCol : " & sRtnCol)


sResult = fGetCellData(sWb, sWs, sKey, sKeyCol, sRtnCol, sErrMsg)

fKey2Val = sResult

End Function


'検索キーからセルデータを取得する""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Private Function fGetCellData(inptWb As String, inptWs As String, inptKey As String, inptKeyCol As String, inptTargetCol As String, inptErrMsg As String) As String

Dim sWbName As String: sWbName = inptWb
Dim sWsName As String: sWsName = inptWs
Dim sKeyCol As String: sKeyCol = inptKeyCol
Dim sKey As String: sKey = inptKey
Dim sTargetCol As String: sTargetCol = inptTargetCol
Dim sMatchRow As String
Dim sRslt As String
Dim sErrMsg As String: sErrMsg = inptErrMsg

On Error Resume Next

With Workbooks(sWbName).Worksheets(sWsName)

    Dim rColKey As Range
    Set rColKey = .Columns(.Cells.Columns(sKeyCol).Column)
    If rColKey Is Nothing Then
        Call printLog(">>FAIL : fGetCellData " & vbNewLine & _
                                        "InptKey : " & inptKey & vbNewLine & _
                                         "WbName : " & sWbName & vbNewLine & _
                                         "WsName : " & sWsName)
        fGetCellData = "#N/A#": Exit Function
    End If
    
    sMatchRow = Application.WorksheetFunction.Match(sKey, rColKey, 0)
    If sMatchRow = "" Then sMatchRow = Application.WorksheetFunction.Match(CLng(sKey), rColKey, 0)
    If sMatchRow <> "" Then
        sRslt = .Cells(CLng(sMatchRow), sTargetCol).Value
    Else
        sRslt = sErrMsg
    End If
End With

fGetCellData = sRslt

End Function



'検索キーから行データを取得する""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Function fGetRowData(inptWb As String, inptWs As String, inptKey As String, inptKeyCol As String) As Variant

Dim sWbName As String: sWbName = inptWb
Dim sWsName As String: sWsName = inptWs
Dim sKeyCol As String: sKeyCol = inptKeyCol
Dim sKey As String: sKey = inptKey
'Dim sTargetCol As String: sTargetCol = inptTargetCol
Dim sMatchRow As String
Dim vRslt As Variant

On Error Resume Next
With Workbooks(sWbName).Worksheets(sWsName)

    Dim rColKey As Range
    Set rColKey = .Columns(.Cells.Columns(sKeyCol).Column)
    If rColKey Is Nothing Then fGetRowData = Array()
    sMatchRow = Application.WorksheetFunction.Match(sKey, rColKey, 0)
    If sMatchRow <> "" Then
            vRslt = Application.Transpose(Application.Transpose(.Rows(CLng(sMatchRow)).Value))
        Else
            vRslt = Array()
    End If

End With

fGetRowData = vRslt

End Function


Function fSplit(ByVal inptStr As String, ByVal inptCol As Integer, Optional ByVal inptSplt As String = ",", Optional inptMatch As Boolean = False) As String
Dim sStr As String: sStr = inptStr
Dim lCol As Integer: lCol = inptCol
Dim sSplt As String: sSplt = inptSplt
Dim sRslt As String
Dim aStr() As String

aStr = Split(sStr, sSplt)

If UBound(aStr) = -1 Or UBound(aStr) = 0 Or lCol = 0 Then
    sRslt = sStr
ElseIf lCol > UBound(aStr) + 1 Then
    sRslt = sStr
ElseIf lCol < 0 Then
    sRslt = aStr(UBound(aStr) + 1 + lCol)
Else
    sRslt = aStr(lCol - 1)
End If


If inptMatch = True And sRslt = inptStr Then sRslt = ""

fSplit = sRslt

End Function

'
'Function fIndent(inptCmd As String, inptTxt As String, inptLv As Integer, Optional inptMax As Integer = 9, Optional inptIndent As Integer = 6) As String
'
'Dim sLhs As String: sLhs = Trim(inptCmd)
'Dim sRhs As String: sRhs = Trim(inptTxt)
'Dim IMax As Integer: IMax = inptMax
'Dim IIdt As Integer: IIdt = inptIndent
'Dim lRpt As Integer
'Dim sPls1 As String: sPls = ""
'
'If inptLv <= 0 Then fIndent = "Division by zero": Exit Function
'
'
'Select Case sLhs
'
'Case "SELECT"
''2
'    sPls1 = "  "
'
'Case "FROM"
''2
'    sPls1 = "  "
'
'Case "AND"
'    sPls1 = "   "
'
'Case "OR"
'    sPls1 = "    "
'
'Case "INSERT"
'    sPls1 = "  "
'
'Case "ALTER"
'    sPls1 = "  "
'
'Case "LEFT JOIN"
'    sPls1 = " "
'
'Case ","
'    sPls1 = "      "
'
'End Select
'
'
'fIndent = Application.WorksheetFunction.Rept(" ", IIdt * CInt(inptLv - 1)) _
'           & sPls1 _
'           & Application.WorksheetFunction.Rept(" ", IMax - Len(sLhs)) _
'           & sLhs _
'           & "  " _
'           & sRhs
'
'End Function



Sub ooo_SQLOWL_ooo()
End Sub


'OwlSql 20211018

'CreateSQLQuery
'UnionAnalogTable
'UnionFPTable
'
'CSV1    CSV2    CSV3    UNIT    FOLDER  NAME    EU  COMMENT DEC1    DEC2    DEC3    BINALY
'[FUNC]          =IF(A2'="*",D1,fSplit(A2,1,"#"))    =IF(B2'="*",E1,fSplit(B2,1,"#"))    =fSplit(C2,1,"#")   =fSplitBetweenAlter($C2,2,"+EU'=","+C'=")    =fSplit($C2,2,"+C'=")   =fSplitBetweenAlter($C2,2,"DEC:","|","TRUE") =fSplitBetweenAlter($C2,2,"|","|","TRUE")    =IF(fSplit(C2,1,"DEC")'=C2,"",fSplitBetweenAlter($C2,3,"|","+EU",TRUE))  =fReplaceRegx(C2,".*(BIN-?\d+).*","$1")

Sub GetQueryResults(SQLQuery As String, WorkBookName As String, WorkSheetName As String)

    Dim DataFilePath As String
    Dim cn As ADODB.Connection
    Dim rs As ADODB.Recordset
    Dim ws As Worksheet
    Dim i As Integer
    Dim RowCount As Long, ColCount As Long
    
    'Exit the procedure if no query was passed in
    If SQLQuery = "" Then
            printLog ("SQL_ERR, Query string missing, You didn't enter a query")
        Exit Sub
    End If
    
    'Check that the Movies workbook exists in the same folder as this workbook
    DataFilePath = WorkBookName
    
    If Dir(DataFilePath) = "" Then
            printLog ("SQL_ERR, File not found, & Dir(DataFilePath")
        Exit Sub
    End If
    
    'Create and open a connection to the Movies workbook
    Set cn = New ADODB.Connection
    cn.ConnectionString = _
        "Provider=Microsoft.ACE.OLEDB.12.0;" & _
        "Data Source=" & DataFilePath & ";" & _
        "Extended Properties='Excel 12.0 Xml;HDR=YES';"
    
    'Try to open the connection, exit the subroutine if this fails
    On Error GoTo EndPoint
    cn.Open
    
    'If anything fails after this point, close the connection before exiting
    On Error GoTo CloseConnection
    
    'Create and populate the recordset using the SQLQuery
    Set rs = New ADODB.Recordset
    rs.ActiveConnection = cn
    rs.CursorType = adOpenStatic
    
    rs.Source = SQLQuery    'Use the query string that we passed into the procedure
    
    'Try to open the recordset to return the results of the query
    rs.Open
    
    'If anything fails after this point, close the recordset and connection before exiting
    On Error GoTo CloseRecordset
    
    'Get count of rows returned by the query
    RowCount = rs.RecordCount
    
    'Debug.Print RowCount & " row(s)", SQLQuery
    
    'Exit the procedure if no rows returned
    If RowCount = 0 Then
            printLog ("SQL_ERR, The query returned no results," & Dir(DataFilePath))
    End If
    
    'Get the count of columns returned by the query
    ColCount = rs.Fields.Count
    
    'Create a new worksheet
    'Set ws = ThisWorkbook.Worksheets.Add
    Set ws = ThisWorkbook.Worksheets(WorkSheetName)
    
    'Select the worksheet to avoid the formatting bug with CopyFromRecordset
    Workbooks(Dir(DataFilePath)).Activate
    ws.Select
    ws.Range("A1:XFD" & Rows.Count).Clear
    
    'Format the header row of the worksheet
    With ws.Range("A1").Resize(1, ColCount)
        .Interior.Color = rgbCornflowerBlue
        .Font.Color = rgbWhite
        .Font.Bold = True
    End With
    
    'Copy values from the recordset into the worksheet
    ws.Range("A2").CopyFromRecordset rs
    
    'Write column names into row 1 of the worksheet
    For i = 0 To ColCount - 1
        With rs.Fields(i)
            ws.Range("A1").Offset(0, i).Value = .Name
            
            'Apply a custom date format to date columns
            If .Type = adDate Then
                ws.Range("A1").Offset(1, i).Resize(RowCount, 1).NumberFormat = "dd mmm yyyy"
            End If
        End With
    Next i
    
    'Change the column widths on the worksheet
    ws.Range("A1").CurrentRegion.EntireColumn.AutoFit
    
    'Close the recordset and connection
    'This will happen anyway when the local variables go out of scope at the end of the subroutine
    rs.Close
    cn.Close
    
    'Free resources used by the recordset and connection
    'This will happen anyway when the local variables go out of scope at the end of the subroutine
    Set rs = Nothing
    Set cn = Nothing
    
    'Exit here to make sure that the error handling code does not run
    Exit Sub
    
'========================================================================
'ERROR HANDLERS
'========================================================================
CloseRecordset:
'If the recordset is opened successfully but a runtime error occurs later we end up here
    rs.Close
    cn.Close
    
    Set rs = Nothing
    Set cn = Nothing
    
'    Debug.Print SQLQuery

    printLog ("SQL_ERR, An error occurred after the recordset was opened.")
    printLog ("Error number: " & Err.Number)
    printLog ("Error description: " & Err.Description)
    Exit Sub

CloseConnection:
'If the connection is opened successfully but a runtime error occurs later we end up here
    cn.Close
    
    Set cn = Nothing
    
   ' Debug.Print SQLQuery
    printLog ("SQL_ERR, An error occurred after the connection was established.")
    printLog ("Error number: " & Err.Number)
    printLog ("Error description: " & Err.Description)
    Exit Sub
    
'If the connection failed to open we end up here
EndPoint:
    printLog ("SQL_ERR, The connection failed to open.")
    printLog ("Error number: " & Err.Number)
    printLog ("Error description: " & Err.Description)
            
End Sub



Sub ooo_SQLQUERY_ooo()

End Sub

'
'
'Sub sample_parentasis()
'Dim sSqlQuery As String
'Dim sWbPath As String
'Dim sWbName As String
'Dim sWsName As String
'Dim sWbDBPath As String
'
''sWbDBPath = " 'C:\Users\Owner\Documents\workspace\DFR3_DB_211004.xlsm' 'Excel 12.0 Xml;HDR=YES' "
'
''Out Setting
'sWsName = "SQL_OUT"
'sWbName = ThisWorkbook.Path & "\" & ThisWorkbook.Name
'Call SelectOrAddWs(sWsName, ThisWorkbook.Name)
'
'Dim sTable1 As String
'Dim sHeader1 As String: sHeader1 = "[DEVICE],[COMMENT],[CATEGORY],[FULL_ADR]"
'Dim sWhere1 As String: sWhere1 = "WHERE CATEGORY LIKE '%VB%' "
'
''OK
'sTable1 = _
'        RetQuerySelectFrom(sHeader1 & ",'PLC03_R'", "[DB_PLC03_R$]") & sWhere1 & _
'sTable1 = "SELECT * FROM (" & sTable1 & " ) "
'
''OK
'sTable1 = _
'        RetQuerySelectFrom(sHeader1 & ",'PLC03_R'", "[DB_PLC03_R$]") & sWhere1 & _
'    "UNION ALL " & _
'        RetQuerySelectFrom(sHeader1 & ",'PLC03_M'", "[DB_PLC03_M$]") & sWhere1 & _
'    "UNION ALL " & _
'        RetQuerySelectFrom(sHeader1 & ",'PLC00_R'", "[DB_PLC00_R$]") & sWhere1 & _
'    "UNION ALL " & _
'        RetQuerySelectFrom(sHeader1 & ",'PLC00_M'", "[DB_PLC00_M$]") & sWhere1 & _
'        " "
'sTable1 = "SELECT * FROM (" & sTable1 & " ) WHERE [CATEGORY] = 'VB' "
'
'sTable1 = _
'" (SELECT " & _
'"    [MAIN].[COL1] , [MAIN].[COL2], [OUTER].[COL3] " & _
'" FROM " & _
'"    [TEST_SHT$] AS [MAIN] " & _
'" INNER JOIN " & _
'"   (SELECT [COL1],[COL3] FROM [TEST_OUTER$] )  AS [OUTER] ON [OUTER].[COL1] = [MAIN].[COL1] )" & _
'" UNION ALL " & _
'" (SELECT " & _
'"    [MAIN].[COL1] , [MAIN].[COL2], [OUTER].[COL3] " & _
'" FROM " & _
'"    [TEST_SHT$] AS [MAIN] " & _
'" INNER JOIN " & _
'"(SELECT [COL1],[COL3] FROM [TEST_OUTER$] )  AS [OUTER] ON [OUTER].[COL1] = [MAIN].[COL1] )" & _
'""
'sSqlQuery = sTable1
'
''Run the query with the SQL string
'Call GetQueryResults(sSqlQuery, sWbName, sWsName)
'
'End Sub


Sub ooo_SQL_QUERY_ooo()
End Sub

Sub sqlTest()
Dim sSqlQuery As String
Dim sWbPath As String
Dim sWbName As String
Dim sWsName As String
Dim sWbDBPath As String
Dim sSelect As String
Dim sFroSht As String
Dim sWhere As String
Dim sSql As String
'sWbDBPath = " 'C:\Users\Owner\Documents\workspace\DFR3_DB_211004.xlsm' 'Excel 12.0 Xml;HDR=YES' "

sWbName = ThisWorkbook.Path & "\" & ThisWorkbook.Name
sSelect = "[FILE],[MARK],[STATUS],[LABEL],[LINE],[C1],[C2],[C3],[C4]"
sFroSht = "[DOWNLOAD$]"

Application.ScreenUpdating = False

sWsName = "SQLOUT"
'sWsName = "SQLOUT_" & Format(Now(), "YYYYMMDDhhmmss")
With SelectOrCreateWs(sWsName, ThisWorkbook.Name)
    .Cells.Clear
End With

'Dim sHeader1 As String: sHeader1 = "[DEVICE],[COMMENT],[CATEGORY],[FULL_ADR]"
'sTable1 = _
'" (SELECT " & _
'"    [MAIN].[COL1] , [MAIN].[COL2], [OUTER].[COL3] " & _
'" FROM " & _
'"    [TEST_SHT$] AS [MAIN] " & _
'" INNER JOIN " & _
'"   (SELECT [COL1],[COL3] FROM [TEST_OUTER$] )  AS [OUTER] ON [OUTER].[COL1] = [MAIN].[COL1] )" & _
'" UNION ALL " & _
'" (SELECT " & _
'"    [MAIN].[COL1] , [MAIN].[COL2], [OUTER].[COL3] " & _
'" FROM " & _
'"    [TEST_SHT$] AS [MAIN] " & _
'" INNER JOIN " & _
'"(SELECT [COL1],[COL3] FROM [TEST_OUTER$] )  AS [OUTER] ON [OUTER].[COL1] = [MAIN].[COL1] )" & _
'""

'ALL
'sWhere = "LEFT([LABEL], 1) = '【'"

'FNC/SQL
'sWhere = "LEFT([LABEL], 4) = '【FNC'" & _
    " OR " & _
        "LEFT([LABEL], 4) = '【SQL'"

'NOT
'sWhere = "LEFT([LABEL], 4) = '【FNC'" & _
           " OR " & _
        "LEFT([LABEL], 4) = '【SQL'"
        
sSql = _
    " SELECT " & _
        sSelect & _
    " FROM " & _
        sFroSht & _
    " WHERE " & _
        sWhere

sSqlQuery = sSql

'Run the query with the SQL string
Call GetQueryResults(sSqlQuery, sWbName, sWsName)

Application.ScreenUpdating = True

End Sub


